Acciones, Transformaciones y Efectos
====================================

.. contents::
    :local:
    
Acciones
--------

Las acciones son como órdenes dadas a cualquier objeto :class:`~cocos.cocosnode.CocosNode` object.

Esas acciones usualmente modifican algún atributo del objeto como por ejemplo
`position`, `rotation`, `scale`, etc.

Por ejemplo, la acción :class:`~cocos.actions.base_actions.MoveBy` modifica el atributo `position` durante cierto período de tiempo

Ejemplo::

    # Mover el sprite 50 píxeles hacia la derecha, y 100 píxeles hacia arriba en 2 segundos.
    sprite.do( MoveBy( (50,100), duration=2 ) )

El comportamiento de las acciones respecto del tiempo las diferencia en tres grupos:

    :class:`InstantAction<cocos.actions.base_actions.InstantAction>` : el cambio se aplica en un paso
    Ejemplo::
    
        # mover instantáneamente el sprite a la posición (120, 330)
        sprite.do( Place( (120, 330) )) 

    :class:`IntervalAction<cocos.actions.base_actions.IntervalAction>` : el cambio se aplica en varios pasos durante cierto tiempo que se conoce al crear la instancia de la acción. Como ejemplo, ver el comando mencionado arriba MoveBy

    :class:`Action<cocos.actions.base_actions.Action>` : el cambio se aplica en varios pasos durante cierto tiempo, pero la duración no se conoce al crear la instancia de la acción o es continua
    
Las acciones IntervalAction tienen algunas propiedades interesantes:

    - El flujo del tiempo se puede modificar usando acciones para alterarlo
    
        + :class:`~cocos.actions.interval_actions.Accelerate`
        + :class:`~cocos.actions.interval_actions.AccelDeccel`
        + :class:`~cocos.actions.interval_actions.Speed`

    - Todas las acciones relativas (las que terminan en 'By') y algunas
      absolutas (las que terminan en 'To') tienen su acción `Reverse` que
      ejecuta la acción en el sentido opuesto.


Acciones Básicas
----------------

Las acciones básicas son las que modifican atributos básicos como:

 - posición
 
    - :class:`~cocos.actions.interval_actions.MoveBy`
    - :class:`~cocos.actions.interval_actions.MoveTo`
    - :class:`~cocos.actions.interval_actions.JumpBy`
    - :class:`~cocos.actions.interval_actions.JumpTo`
    - :class:`~cocos.actions.interval_actions.Bezier`
    - :class:`~cocos.actions.instant_actions.Place`

 - tamaño
 
    - :class:`~cocos.actions.interval_actions.ScaleBy`
    - :class:`~cocos.actions.interval_actions.ScaleTo`

 - rotación
 
    - :class:`~cocos.actions.interval_actions.RotateBy`
    - :class:`~cocos.actions.interval_actions.RotateTo`

 - visibilidad
 
    - :class:`~cocos.actions.instant_actions.Show`
    - :class:`~cocos.actions.instant_actions.Hide`
    - :class:`~cocos.actions.interval_actions.Blink`
    - :class:`~cocos.actions.instant_actions.ToggleVisibility`

 - opacidad
 
    - :class:`~cocos.actions.interval_actions.FadeIn`
    - :class:`~cocos.actions.interval_actions.FadeOut`
    - :class:`~cocos.actions.interval_actions.FadeTo`
    

Se pueden ver ejemplos de MoveBy en ``test/test_<action name>.py`` , like ``test/test_moveby.py``

Acciones Especiales
-------------------

**relativas al tiempo:** no realizar acciones durante un lapso
  - :class:`~cocos.actions.interval_actions.Delay`
  - :class:`~cocos.actions.interval_actions.RandomDelay`

**control de flujo:**  llamar a una determinada función. Se usa normalmente junto con el operador de secuencia que expresa la semántica 'al finalizar accion_1 llamar a esta función' 
  - :class:`~cocos.actions.instant_actions.CallFunc`
  - :class:`~cocos.actions.instant_actions.CallFuncS`

**ayudantes de grilla:** ayudantes para realizar acciones en una grilla
  - :class:`~cocos.actions.basegrid_actions.StopGrid`
  - :class:`~cocos.actions.basegrid_actions.ReuseGrid`
  
**relativos a la cámara**
  - :class:`~cocos.actions.camera_actions.OrbitCamera`
 

Composición y modificación de acciones
--------------------------------------

Cocos también viene con algunos operadores poderosos que combinan o modifican
acciones, entre los que se destacan los que se listan a continuación. Ver los
ejemplos ejecutables del tipo ``test_<nombre del operador o modificador>.py``

**operador de secuencia:**   accion_1 + accion_2 -> accion_compuesta

Donde accion_compuesta consiste en primero realizar todo lo que haría accion_1
y luego realizar todo lo que haría accion_2

Ejemplo de uso::

    mover_2 = MoveTo((100, 100), 10) + MoveTo((200, 200), 15)

Cuando se active, mover_2 moverá el objeto primero hacia (100, 100) y arribará
a esa posición a los 10 segundos de partir; luego moverá el objeto hacia
(200, 200), y arribará a la posición luego de otros 10 segundos

**operador spawn:**  accion_1 | accion_2 -> accion_compuesta

Donde accion_compuesta consiste en hacer lo que haría accion_1 en paralelo con
lo que haría accion_2

Ejemplo de uso::

    mover_rotando = MoveTo((100,100), 10) | RotateBy(360, 5)

Al activarse, mover_rotando moverá el objeto desde la posición al momento de
activarse hasta (100, 100); además en los primeros 5 segundos el objeto se
rotará 360 grados

**operador de bucle:**   accion_1 * n -> accion_compuesta

Siendo n un entero no negativo; accion_compuesta repetirá n veces seguidas lo
mismo que haría accion_1.

Ejemplo de uso::

    rotar_3 = RotateBy(360, 5) * 3

Al activarse, rotar_3 rotará el objeto 3 veces, utilizando 5 segundos en cada
rotación.

**bucle continuo:**  Repeat(accion_1) -> accion_compuesta

Donde accion_compuesta realiza accion_1 y luego repite accion_1 cada vez que accion_1 finaliza

Ejemplo de uso::

    rotar_siempre = Repeat(RotateBy(360, 3))

Al activarse, el objeto rotará continuamente, dando una vuelta completa cada 3 segundos

**modificadores del flujo del tiempo**
    - :class:`~cocos.actions.interval_actions.Accelerate`
    - :class:`~cocos.actions.interval_actions.AccelDeccel`
    - :class:`~cocos.actions.interval_actions.Speed`
    - :class:`~cocos.actions.base_actions.Reverse`

**modificadores de amplitud de grillas**
    - :class:`~cocos.actions.basegrid_actions.AccelAmplitude`
    - :class:`~cocos.actions.basegrid_actions.DeccelAmplitude`
    - :class:`~cocos.actions.basegrid_actions.AccelDeccelAmplitude`
    

Efectos
-------

Los efectos son tipos especiales de acción. En lugar de modificar atributos
normales como *position*, *rotation*, *color*, o *scale*, modifican un nuevo
tipo de atributo: el atributo **grid** (grilla).

Un atributo grid es como una matriz, es una red de líneas que se cruzan unas a
otras para formar una serie de rectángulos o cuadrados.

Estas acciones especiales distribuyen cualquier objeto `CocosNode` (`Layer`, `Scene`, etc.)
en el grid, y puedes transformar este grid moviendo sus vértices.

Hay dos tipos de grid: ``tiled`` (en mosaico) y ``non-tiled`` (sin mosaico). La
diferencia está en que el grid en mosaico está compuesto por mosaicos individuales
mientras que el otro grid se compone de vértices.

.. image:: tiled_and_nontiled_grid.png

El grid tiene dos dimensiones: ``rows`` (filas) y ``columns`` (columnas) pero
cada vértice de la grilla tiene tres dimensiones: ``x``, ``y`` y ``z``. Así puedes
crear efectos 2d o 3d haciendo transformaciones de grillas 3d con o sin mosaico.

Se puede mejorar la calidad de los efectos aumentando el tamaño de la grilla, 
pero la velocidad del efecto disminuye.

Un tamaño de grilla (16, 12) hará que la velocidad sea mayor en casi cualquier
computadora pero no se verá demasiado bien. Y una grilla de (32, 24) se verá
mejor, pero la velocidad no será tan buena en computadoras viejas.

Cómo Funcionan
^^^^^^^^^^^^^^

En cada cuadro la pantalla se convierte en una textura. Esta textura se transforma en un arreglo de vértices
y ese arreglo de vértices (la grilla!) es modificado por los efectos de grilla. Finalmente el arreglo de 
vértices se convierte en la pantalla.

Para más detalle sobre cuestiones internas ver:
 - :class:`~cocos.grid.TiledGrid3D` y :class:`~cocos.actions.basegrid_actions.TiledGrid3DAction` para las grillas ``tiled`` (con mosaico)
 - :class:`~cocos.grid.Grid3D` y :class:`~cocos.actions.basegrid_actions.Grid3DAction` para las grillas ``non-tiled`` (sin mosaico)

Por ejemplo, si tienes una escena o capa que convierte a esta imagen:

.. image:: original_image.png

...Podemos transformar la imagen en esta otra usando la acción :class:`~cocos.actions.grid3d_actions.Ripple3D`.
Como puedes ver en la imagen **de alambres**, esta usando una grilla de 32x24 cuadrados,
y la grilla es *sin mosaico* (todos los cuadros están unidos).

.. image:: effect_ripple3d.png
.. image:: effect_ripple3d_grid.png

...o podemos transformarla en esta otra usando la acción :class:`~cocos.actions.tiledgrid_actions.FadeOutTRTiles`.
Como puedes ver en la imagen **de alambres**, está usando una grilla de 16x12 cuadrados,
y la grilla es *con mosaico* (todos los cuadrados/mosaicos se pueden separar).

.. image:: effect_fadeouttiles.png
.. image:: effect_fadeouttiles_grid.png


Acciones 3D
^^^^^^^^^^^

Los nombres de acción que tienen las letras '3D' indican que producen un
efecto visual 3D al modificar la coordenada z de la grilla.

Si vas a utilizar alguna acción  '3D', probablemente querrás habilitar las
pruebas de profundidad de OpenGL. Una forma fácil de hacer esto es llamar al
método `set_depth_test` del Director.


Índice de efectos de la grilla
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Se pueden hallar todas las acciones `Grid3DAction` aquí:
 - :mod:`cocos.actions.grid3d_actions`

Y todas las acciones `TiledGrid3DAction` aquí:
 - :mod:`cocos.actions.tiledgrid_actions`



Ejemplos
^^^^^^^^

Algunos ejemplos::

    # efecto aplicado a una escena
    scene.do( Twirl( grid=(16,12), duration=4) )

    # efecto aplicado a una capa
    layer1.do( Lens3D( grid=(32,24), duration=5 )

    # efecto aplicado a otra capa
    layer2.do( Waves( grid=(16,12), duration=4) + Liquid( grid=(16,12), duration=5 ) )
    
Se pueden consultar ejemplos ejecutables como ``test/test_<nombre de la acción>.py`` , por ejemplo ``test/test_lens_3d.py``
	
    
Creando tus propias acciones
----------------------------

Es fácil crear tus propias acciones. Deberías familiarizarte con estos conceptos,
porque las acciones son muy potentes y se pueden combinar con otras acciones para crear más acciones.

Por ejemplo, está la acción Blink (parpadeo). Está implementada como subclase de `IntervalAction`,
pero podrías fácilmente hacer algo como::

    def Blink(times, duration): 
        return (
            Hide() + Delay(duration/(times*2)) + 
            Show() + Delay(duration/(times*2)) 
        ) * times
    
Cuestiones básicas internas
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Toda acción se aplica a un `target` u objeto destino. Establecer el objeto
correcto como target es responsabilidad del que invoca la acción. Esto permite
al usuario crear instancias de acciones y luego aplicar las mismas acciones a
distintos elementos. Cualquier elemento cocosnode puede ser target de una acción.

No se sabe quién es el target al momento de llamar a `__init__` o `init`, pero si es posible saberlo cuando se
llama a `start`. Si estás creando una acción que recibe otras acciones como parámetros, debes asegurarte de:

 * establecer el target
 * llamar al método start
 * llamar al método stop

Además puedes sobreescribir el método `__reversed__`. En ese método debes construir y devolver una acción
que sería versión inversa de la acción que estás haciendo. Por ejemplo, en `Show()` se devuelve `Hide()`
como su inversa::

    class Show( InstantAction ):
        "<snip>"
        def __reversed__(self):
            return Hide()

Acciones Instantáneas
^^^^^^^^^^^^^^^^^^^^^

Las acciones instantáneas son acciones que se realizan sin transcurso de tiempo.
Por ejemplo, `Hide()` deshabilita la visibilidad del objeto destino.

Es muy fácil crear una acción usando la acción CallFuncS como decorador::

    @CallFuncS
        def make_visible( sp ):
            sp.do( Show() )
        self.sprite.do( make_visible )

ten en cuenta que make_visible no será una función normal que puedas llamar,
será una acción. De esta forma puedes combinar la acción como cualquier otra.

Si quieres crear sublcases de InstantAction, deberás sobreescribir:
  - el método `init` para que acepte los parámetros que desees
  - el método `start` para realizar la acción
  
Eso es todo.

Por ejemplo, esta es una implementación mínima de SetOpacity::

    class SetOpacity( InstantAction ):
        def init(self, opacity):
            self.opacity = opacity
        def start(self):
            self.target.opacity = self.opacity

Acciones por Intervalos
^^^^^^^^^^^^^^^^^^^^^^^

Las acciones por intervalos son las más divertidas. Con estas acciones puedes
especificar transformaciones que llevan un tiempo determinado. Por ejemplo,
`MoveBy(how_much, duration)`.

El protocolo de las subclases de `IntervalAction` es el siguiente:
   - Se llama al método `init`. Aquí se debe establecer la propiedad `duration`
   - Se hará una copia de la instancia (no debes ocuparte de eso)
   - Se llama al método `start` (y se establece `self.target`)
   - `update(t)` será llamado casi siempre periódicamente con valores dentro
     del intervalo [0,1) y t aumentará en forma monótona.
   - Se llama a `stop()`.

De esta forma, la magia se realiza en el método update. Por ejemplo, si deseas
que algo se desvanezca, puedes escribir algo como::

    class FadeOut( IntervalAction ):
        def init( self, duration ):
            self.duration = duration

        def update( self, t ):
            self.target.opacity = 255 * (1-t)

        def __reversed__(self):
            return FadeIn( self.duration )

El truco consiste en que quien sea que esté corriendo tu acción interpolará los valores de t
para avisarte que `t==1` cuando la duración se acabe. Esto no significa que han transcurrido
`duration` segundos, pero por lo común coincide. Si alguien quiere hacer que tu acción vaya
el doble más rápido, puede aumentar las actualizaciones a una frecuencia distinta y tu no
necesitas preocuparte.

Además, esto permite cambiar el método de interpolación. Normalmente usamos interpolación lineal,
pero `AccelDeccel`, por ejemplo, usa una función sigmoide para que se haga más lenta al finalizar.


Acciones de grillas
^^^^^^^^^^^^^^^^^^^

Son acciones tipo `IntervalAction`, pero en lugar de modificar atributos
*normales* como *rotation*, *position*, *scale*, modifican el atributo *grid*

Veamos en detalle cómo construir una acción básica *non-tiled-grid* (de grilla
sin mosaico)::

    class Shaky3D( Grid3DAction):

*Shaky3D* es una subclase de `Grid3DAction`, y por lo tanto estamos creando una
acción *non-tiled* (sin mosaico). Si deseamos crear una acción *tiled* (con
mosaico), necesitamos crear una subclase de `TiledGrid3DAction`::

        def init( self, randrange=6, *args, **kw ):
            '''
            :Parámetros:
                `randrange` : int
                    Número que será usado en random.randrange( -randrange, randrange) para crear el efecto
            '''
            super(Shaky3D,self).init(*args,**kw)

            #: intervalo aleatorio del efecto shaky
            self.randrange = randrange

Nuestra clase recibe el parámetro ``randrange``, así que lo guardamos, y llamamos al ``init``
de la clase super::

        def update( self, t ):
            for i in xrange(0, self.grid.x+1):
                for j in xrange(0, self.grid.y+1):
                    x,y,z = self.get_original_vertex(i,j)
                    x += random.randrange( -self.randrange, self.randrange+1 )
                    y += random.randrange( -self.randrange, self.randrange+1 )
                    z += random.randrange( -self.randrange, self.randrange+1 )

                    self.set_vertex( i,j, (x,y,z) )

Como en cualquier otra acción `IntervalAction`, el método ``update`` será llamado
una vez por cuadro. De esta forma, nuestro efecto *Shaky3D* modificará las
coordenadas ``x``, ``y`` y ``z`` con un número aleatorio que se obtiene en la
función ``random.randrange``.

El método `get_original_vertex` devuelve las coordenadas ``x`` e ``y`` originales
del vértice, mientras que el método `get_vertex` devuelve las coordenadas ``x``
e ``y`` actuales del vértice.

XXX: Explicar cómo se crea una Acción con mosaico
XXX: Cómo usar: `get_original_tile` y `get_tile`
