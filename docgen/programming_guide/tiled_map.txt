Mapas de mosaicos
=================

El módulo :mod:`cocos.tiles` viene con un método simple para manejar
mosaicos de imágenes en juegos 2d.

Los mapas de mosaicos se dividen en tres elementos:

imágenes
   Las imágenes van de imágenes individuales a atlas de imágenes en un archivo.
Mosaicos
   Los mosaicos pueden ser independientes o parte de un conjunto TileSet.
Mapas
   Los objetos MapLayer se componen de celdas rectangulares o hexagonales que
   que se asocian a los mosaicos que se usan para dibujar cada celda      
Objetos tmx
   Son entidades que no se pueden alinear en una grilla, ver
   `Soporte para capas de objetos TMX`_.
   Actualmente solo disponible si se carga desde un archivo .tmx.

cocos.tiles soporta dos formatos de archivo:   

1. El formato de archivo TMX como es generado por el editor de mapas
   de mosaicos en <http://mapeditor.org>.
2. Un formato XML interno de cocos2d que el puede leer y escribir descripto
   más abajo en `La especificación del archivo XML`_. 

Los dos tipos de archivo se cargan con el mismo comando de la API::

    #Esto carga un mapa en formato TMX
    cocos.tiles.load('filename.tmx')

    #Esto carga un mapa en formato XML de cocos2d
    cocos.tiles.load('filename.xml')

Una vez que se ha cargado el mapa la API para acceder a la información del mapa
es la misma sin importar el formato en el disco.

Hay ejemplos sencillos para usar el módulo cocos.tiles en
test/test_tiles.py, test/test_tmx.py y test_platformer.py

Hay disponible un editor básico para mapas de mosaicos en tools/editor.py;
usa tools/gentileset.py si quieres un archivo .xml por cada tileset utilizado.


Mapas
-----

La clase :class:`.RectMapLayer` extiende la capa básica de Cocos para poder
manejar un conjunto de imágenes en mosaico, o celdas. La capa del mapa se puede
manejar como cualquier otra capa de Cocos. También incluye métodos para
explorar los contenidos de los mapas y hallar celdas (por ejemplo las que se
situan debajo del cursor del mouse) o celdas cercanas (arriba, abajo,
izquierda, derecha)

Los mapas pueden ser definidos con código Python, pero es un tanto más fácil
hacerlo en XML. Para el soporte para edición de mapas, los mapas aceptan
conversión en ambas direcciones de XML.


La especificación del archivo XML
---------------------------------

La idea es que se podría tener un conjunto en mosaico definido en un archivo
XML que pueda compartir entre distintos archivos de mapa (o de hecho dentro de
un mismo archivo). Las imágenes pueden ser compartidas entre múltiples mosaicos
con los archivos agregando metadatos para cada caso.

Esos archivos podrían ser construidos manualmente o cargados desde archivos de
recursos en XML que se utilicen para las especificaciones de los conjuntos y
mapas de mosaicos. Un determinado archivo de recursos en XML podría definir
múltiples conjuntos de mosaicos y mapas e incluso hacer referencia a
archivos de recursos en XML externos. Esto permitiría que un solo conjunto de
mosaico pueda ser usado por varios mapas de mosaicos.

Suponiendo el siguiente archivo XML llamado "ejemplo.xml"::


    <?xml version="1.0"?>
    <resource>
      <requires file="ground-tiles.xml" namespace="ground" />

      <rectmap id="level1">
       <column>
        <cell tile="ground:grass" />
        <cell tile="ground:house">
          <property type="bool" name="secretobjective" value="True" />
        </cell>
       </column>
      </map>
    </resource>

Podría cargarse ese recurso y examinarlo::

  >>> r = load('ejemplo.xml')
  >>> map = r['level1']

y luego, suponiendo que level1 es un mapa::

  >>> scene = cocos.scene.Scene(map)

y entonces incluso seleccionar manualmente los mosaicos a mostrar:

  >>> map.set_view(0, 0, window_width, window_height)

o si quisieras que el nivel se deslice, podrías usar el ScrollingManager::

  >>> from cocos import layer
  >>> manager = layer.ScrollingManager()
  >>> manager.add(map)

y luego establecer el foco con::

  >>> manager.set_focus(focus_x, focus_y)

Ver la sección `Controlando el Desplazamiento del Mapa`_ más abajo para más
detalle.


Contenido de archivo en XML
---------------------------

Los archivos XML con recursos deben contener una etiqueta <resource> en el
nivel superior del documento::

    <?xml version="1.0"?>
    <resource>
     ...
    </resource>

Puedes incluir otros archivos de recursos utilizando la etiqueta <requires>::

    <requires file="road-tiles.xml" />

Esto hará que se cargue "road-tiles.xml" en el namespace del recurso.
Si quieres evitar conflictos de id puedes definir el namespace::

    <requires file="road-tiles.xml" namespace="road" />

Cuando se especifica el namespace entonces los id de cada elemento de
"road-tiles.xml" llevarán el namespace como prefijo seguido de dos puntos,
por ejemplo "road:bitumen".

Otras etiquetas dentro de <resource> son::

    <image file="" id="">

Carga un archivo con pyglet.image.load y le asigna un id que es usado por
los mosaicos para asignarlo a la imagen.

::

<imageatlas file="" [id="" size="x,y"]>

Configura un atlas de imágenes para ser usado por las etiquetas <image> hijas.
Las etiquetas <image> hijas son del tipo::

    <image offset="" id="" [size=""]>

Si la etiqueta <imageatlas> no contiene el atributo size entonces todas las
etiquetas <image> hijas deben contenerlo. Los id de las etiquetas imageatlas
son opcionales ya que por ahora no tienen referencias directas.

::

    <tileset id="">

Define un objeto TileSet. Las etiquetas hijas tienen la forma::

   <tile id="">
     [<image ...>]
   </tile>

La etiqueta <image> es opcional; estos mosaicos pueden solo contener
propiedades (o estar completamente vacíos). El id es utilizado por los mapas
para identificar el mosaico.

.. Warning::
    Actualmente tools/editor.py no puede guardarse si se incluye un tileset en el archivo xml

    Solución: usar tools/gentileset.py para crear un xml para cada tileset que se use, y entonces incluir el mapa usando un elemento::

        <requires file="my-tiles.xml" ...>

    para cada tileset.


::

    <rectmap id="" tile_size="" [origin=""]>

Establece un objeto RectMap. Las etiquetas hijas son del tipo:: 

   <column>
    <cell tile="" />
   </column>

.. _cell_properties_label:

Propiedades de los Mosaicos, Celdas y Mapas
-------------------------------------------

La mayoría de las etiquetas pueden especificar propiedades adicionales con el
formato::

   <property [type=""] name="" value="" />

Donde type puede ser "unicode", "int", "float" o "bool". Por defecto será una
cadena unicode en caso de no especificarse.

Se accede a las propiedades de mapas, celdas o mosaicos utilizando las
operaciones usuales de objetos dict con algunas extensiones. Si se accede a una
propiedad de una celda y la celda no la especifica, se intentará como segunda
opción recuperar el valor en el mosaico.

Si una celda tiene una propiedad llamada ``player-spawn`` (booleano) y el
mosaico usado por la celda tiene una propiedad ``move-cost=1`` (entero),
se cumple lo siguiente::

    'player-spawn' in cell == True
    cell.get('player-spawn') == True
    cell['player-spawn'] == True

    'player-spawn' in tile == False
    tile.get('player-spawn') == None
    tile['player-spawn'] --> genera una excepción KeyError

    cell['move-cost'] == 1

Además puedes especificar propiedades en celdas y mosaicos::

    cell['player-position'] = True
    cell['burnt-out'] = True

y cuando el mapa se exporte a XML estas propiedades también se incluirán.


Controlando el Desplazamiento del Mapa
--------------------------------------

You have three options for map scrolling:

1. Never automatically scroll the map.
2. Automatically scroll the map but stop at the map edges.
3. Scroll the map an allow the edge of the map to be displayed.

The first is possibly the easiest since you don't need to use a
:class:`.ScrollingManager` layer. You simple call ``map.set_view(x, y, w, h)``
on your map layer giving the bottom-left corner coordinates and the dimensions
to display. This could be as simple as::

   map.set_view(0, 0, map.px_width, map.px_height)

If you wish to have the map scroll around in response to player
movement the :class:`.ScrollingManager` from the :mod:`.cocos.layer.scrolling`
module may be used.


Map Queries
-----------

Maps have a ``map.get_at_pixel(x, y)`` query which will return the Cell at 
that position in the Map.

Given a Cell object you may also use ``map.get_neighbor(cell, direction)`` to 
get the Cell which is in the direction (one of ``map.UP``, ``map.DOWN``,
``map.LEFT`` or ``map.RIGHT``.)


Handling collisions between actors and tiles
--------------------------------------------

See :doc:`mapcoliders`

Rectangular Maps
----------------

Cells are stored in column-major order with y increasing up,
allowing [i][j] addressing::

 +---+---+---+
 | d | e | f |
 +---+---+---+
 | a | b | c |
 +---+---+---+

The cells property is list of lists: ``[['a', 'd'], ['b', 'e'],
['c', 'f']]``

Thus the cell at (0, 0) is 'a' and (0, 1) is 'd'.


Support for .TMX maps with hexagonal tiles
------------------------------------------

To have the same visualization in cocos than in Tiled Editor, you should set 
in Tiled the following map properties:

    - 'orientation': 'hexagonal'.
    - 'staggeraxis': 'x' (top and bottom hexagon sides parallel to the x 
      axis).
    - 'staggerindex': 'even' (lower columns are the even ones).
    
Draw order is not guaranteed by cocos, so tilesets which expands outside the 
hexagon will not look good.


Soporte para capas de objetos TMX
---------------------------------

El formato de mapas TMX permite especificar 'capas de objetos' también
conocidas como 'grupos de objetos'.

Una 'capa de objetos' es una colección de entidades ubicadas libremene en el
mundo, es decir, no es necesario alinearlas con la grilla de un mosaico.

Los objetos pueden definir 'ellipse', 'polygon', 'polyline', 'rect' o 'tile'
abstractos.

Cuando se carga un archivo TMX cada 'capa de objetos' crea una instancia de
:class:`.TmxObjectLayer`, el elemento '.objects' contiene una lista de objetos
en el grupo, cada uno traducido como instancia de :class:`.TmxObject`.

Cocos no tiene como fin proveer de una visualización real del :class:`.TmxObject`,
para depuración, si se agrega :class:`.TmxObjectLayer` a la escena, se
dibujará la caja alineada con ejes de cada objeto.

A menudo, despues de cargar el mapa, el código de tu aplicación recorre el
contenido de '.objects' y realiza acciones convenientes, por ejemplo:

    - crea un :class:`.CocosNode` específico para visualización (sistema de
      partículas, sprite animado, ...) basado en ``TmxObject.usertype`` y otros
      atributos, y luego lo agrega a la escena.
    - traduce a alguna clase del modelo, como el control de una zona de
      detección o la trayectoria de una patrulla y almacena los datos del nivel

Aparte de la visa de depuración, :class:`.TmxObjectLayer` cuenta con algunos
métodos para seleccionar objetos según ciertas propiedades o dentro de un área
específica.

