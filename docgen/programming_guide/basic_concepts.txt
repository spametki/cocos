Basic Concepts
==============

Hay algunos conceptos básicos que se incluyen en esta librería que te harán
falta cuando desarrolles una aplicación de cocos2d:

.. contents::
    :local:

.. _guide_scene:

Escenas
-------

Una escena (implementada en la clase :class:`~cocos.scene.Scene`) es una pieza más o
menos independiente del flujo de trabajo de la aplicación.
También se la puede llamar "pantalla" o "etapa". Tu aplicación puede tener muchas
escenas, pero sólo una de ellas está activa en un momento determinado.

Por ejemplo, podrías tener un juego con las siguientes escenas:
Intro, Menú, Nivel 1, Transición 1, Nivel 2, Juego terminado (ganador),
Juego terminado (perdedor), Tabla de puntajes.

Puedes definir cualquiera de esas escenas más o menos como aplicaciones independientes;
hay algunas conexiones lógicas entre ellas (la Intro va al Menú cuando se interrumpe o
finaliza, el Nivel 1 te lleva a la Transición 1 si finaliza o a Juego Terminado cuando
pierdes, etc.).

.. figure:: scenes.png


Una escena en cocos2d está conformada por un árbol de elementos :class:`CocosNode` donde
la raíz es un nodo de tipo :class:`.Scene` (escena), los descendientes más próximos normalmente
son de tipo :class:`.Layer` (capa), y estos contienen y organizan los elementos individuales.


Ejemplo de pantalla principal del menú::

        escena_menu_principal : Scene que contiene todos los elementos del menú principal
                fondo_animado : Layer con un fondo animado
                        fondo_estatico : Sprite con un buen dibujo que abarca toda la pantalla
                        arboles_lejanos: Layer conteniendo los árboles más distantes
                                arbol_1 ... arbol_k : Sprites que muestran árboles
                        pajaros : Layer conteniendo pájaros voladores
                                pajaro_1 ... pajaro_n : Sprites mostrando aves
                        arboles_cercanos : Layer conteniendo los árboles más cercanos
                                arbol_1 ... arbol_m : Sprites mostrando árboles
                menu_principal : Menu, una subclase de Layer que pertenece a cocos y que maneja
                                        todo lo relacionado al menú (eventos de teclado,
                                        resaltado, selección ...)
			item1 : MenuItem , 'jugar'
			item2 : MenuItem , 'opciones'
			item3 : MenuItem , 'salir'

Además hay una familia de subclases de `Scene` llamadas transiciones (implementadas
en el objeto :class:`~cocos.scenes.transitions.TransitionScene`), que te permiten
hacer transiciones entre dos escenas (fundidos, desplazamientos laterales, etc).

Como las escenas son subclases de :class:`.CocosNode`, se pueden transformar manualmente
o usando acciones.
Ver :doc:`actions` para más información sobre acciones.

Director
--------

El **director** es el componente que se ocupa de ir hacia adelante y hacia
atrás entre escenas.

El director es un objeto (singleton) compartido. Sabe qué escena está activa
actualmente, y maneja una lista de escenas para permitir cosas como"llamados
de escenas"
(al pausar un objeto :class:`.Scene` y ponerlo en espera mientras entra otro, y luego
regresando al original). Las modificaciones en la pila como agregar y reemplazar o finalizar
la escena las hace el director.

El director también es el responsable de inicializar la ventana principal.

Para obtener el objeto director debes hacer::

	import cocos
	from cocos.director import director

La implementación está ubicada en :mod:`cocos.director`

.. _guide_layer:

Capas
-----

Las capas te ayudan a organizar la escena múltiples planos, por ejemplo

        - fondo : un dibujo fijo que hace de paisaje
        - lejos : árboles decorativos y aves
        - medio : plataformas
        - cerca : jugador, enemigos, monedas
        - HUD : datos superpuestos para mostrar estadísticas del juego como vida y energía

Se puede pensar las capas (usualmente) como hojas transparentes donde los hijos se distribuyen,
y la escena como una pila de hojas.


.. image:: layers.png

En estilos de diseño distintos a MVC (modelo - vista - controlador), parte del código relacionado
con la interacción con nodos tiende a flotar sobre la capa que contiene las entidades, dando
lugar a unidades funcionales superiores.
Por ejemplo, :class:`Menu` es una subclase de Layer que sabe como organizar y animar los ítem,
leer acciones del usuario y hacer el control de flujo.

Las capas son las que definen la apariencia y el comportamiento, así que la mayor
parte del tiempo lo emplearás programando subclases de :class:`Layer` que hagan lo
que necesites.

El :class:`.Layer` es donde defines los manejadores de eventos. Los eventos se propagan
a las capas (de adelante hacia atrás) hasta que alguna capa lo detecte y lo acepte.

Aunque toda aplicación seria requiere definir alguna sublcase de :class:`Layer`, cocos2d
cuenta con algunas capas especializadas que son útiles:

	- :class:`.MultiplexLayer`, un grupo de capas donde solo una es visible cada vez
	- :class:`.ScrollingManager`, :class:`~cocos.layer.scrolling.ScrollableLayer`; se encarga de la lógica para limitar el desplazamiento a un área visible
	- :class:`.RectMapLayer`, :class:`.HexMapLayer`, :class:`.TmxObjectLayer`; muestra un grupo de divisiones rectangulares o hexagonales u objetos TMX
	- :class:`.Menu`, implementa un sistema simple de menús
	- :class:`.ColorLayer`, un rectángulo de color sólido
	- :class:`.PythonInterpreterLayer`, es usado por el director para mostrar una consola interactiva para explorar los objetos en tu escena (ctrl + I para habilitar-deshabilitar)


Para cargar los recursos apropiadamente con más facilidad puedes sobreescribir el
método ``__init__`` de tu subclase de :class:`.Layer`. Este será llamado cuando
se cree tu capa.

Como las capas son subclases de :class:`.CocosNode`, se pueden transformar manualmente o
utilizando acciones. Ver :doc:`actions` para más detalles sobre acciones.


Sprites
-------

Un sprite de cocos2d es como cualquier otro sprite de computadora.
Es una imagen 2d que se puede mover, rotar, escalar, animar, etc.


Los sprite (implementados utilizando la clase :class:`.Sprite`) pueden tener
otros sprite hijos. Cuando el padre se transforma, todos sus hijos también
se transforman.

Como los sprite son subclases de :class`.CocosNode, se pueden transformar manualmente
o usando acciones. Ver :doc:`actions` para más detalles sobre acciones.



Eventos
-------

cocos2d usa `The pyglet Event Framework`_ para manejar eventos.

Miniresumen de pyglet event framework
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 - tienes **emitters** (instancias de `pyglet.event.EventDispatcher <http://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/api/pyglet/event/pyglet.event.EventDispatcher.html>`_)

 - cada emitter puede registrar tantos eventos como se desee, cada uno identificado por una cadena (el nombre del evento)

 - para actuar según los eventos, se registran **listeners** con el emitter.
   Básicamente, se provee al emitter de un (<nombre del evento>, función) y el emitter se encargará de llamar a la función cuando ocurra <nombre del evento>. Se pueden asociar ilimitados listeners a un par (emitter, <nombre del evento>). Un listener puede asociarse a ilimitados emitters.

 - ejemplo de registro de eventos **emitter**::

        class Bunker(pyglet.event.EventDispatcher):
            ...
            def building_update(self, dt):
                ...
                if self.elapsed_time>self.building_time:
                    self.dispatch_event('on_building_complete', self)

            def take_damage(self, damage):
                self.dispatch_event('on_building_under_attack', self)
                self.life -= damage
                if self.life<0:
                    self.dispatch_event('on_building_destroyed', self)

        # Las líneas siguientes registran los eventos que pueden emitir
        # las instancias de Bunker
        Bunker.register_event_type('on_building_complete')
        Bunker.register_event_type('on_building_under_attack')
        Bunker.register_event_type('on_building_destroyed')


   Ten en cuenta que un evento puede recibir cualquier número de argumentos o
   ninguno; aquí especificamos la instancia que emite el evento.


 - ejemplo de registro de **listeners**::
     
        class Commander(object):
            def __init__(self, ...):
                self.buildings = []
                ...

            def invest_resources(self):
                ...
                bunker = Bunker(...)
                # register to receive all events from object bunker
                bunker.push_handlers(self)
                self.buildings.append(bunker)
                ...

            # handlers for the events

            def on_building_complete(self, building):
                ...

            def on_building_under_attack(self, building):
                ...

            def on_building_destroyed(self, building):
                ...

   Ten en cuenta que los manejadores de eventos reciben los parámetros que a fueron pasados a los eventos.
   El registro de manejadores de eventos funciona de este modo:

       - se pasa una instancia de clase a push_andlers
       - pyglet examina los métodos en esta instancia de clase que tengan el <nombre de evento> para cada <nombre de evento> que haya registrado el emitter, y luego registra los ( <nombre de evento>, obj.nombre_de_evento ) por cada coincidencia.


   Con este tipo de registro de eventos debes tener cuidado cuando registras
   para dos emitter: si ambos emitter pueden generar eventos 'on_cuack'
   y tu registras::

        emitter1.push_handlers(obj)
        emitter2.push_handlers(obj)

   entonces obj.on_cuack será llamado por los dos emitter.

   Otro tipo de registro de listeners es agregar manejadores explícitos::

        bunker.push_handlers(
            self.on_building_complete,
            self.on_building_under_attack,
            self.on_building_destroyed
            )

 - Si quieres que un listener deje de recibir eventos de un emitter, desregistras el listener::

        emitter.remove_handlers(...) # los parámetros igual que en push_handlers


 - Propagación de eventos : Un evento se propaga a todos los manejadores desde lo más alto de la pila del emitter hasta que devuelve EVENT_HANDLED (cuyo valor es True).




Cocos y los eventos
^^^^^^^^^^^^^^^^^^^

Aparte de usar eventos para obtener comandos del usuario ('on_key_press', 
'on_mouse_move', ...) o cambios de status de la ventana ( 'on_activate', ...),
puedes usar eventos para desacoplar el modelo de la vista en la aplicación. El juego
Tetrico, que se puede ver en samples/tetrico es un ejemplo de esta técnica.

Cocos en general **no** manejará automáticamente el registro/desregistro de listeners,
salvo para un caso especial: cuando el emitter es director.window y el listener es una capa
o escena. Por eso, para los casos comunes, debes manejar la cuestión push_handlers - remove_handlers
por tu cuenta.
Cuando tu listener pertenece a un CocosNode, un buen esquema consiste en agregar manejadores en el
método on_enter y quitar los manejadores en el método on_exit. De esta forma, te aseguras de que
tus manejadores no serán llamados cuando el nodo no está en la escena activa.
Además, para eventos personalizados, es buena práctica no usar nombres de eventos que sean
utilizados por director.window: esto evita llamadas duplicadas al manejador o manejadores.


Para el caso especial en que el emitter es director.window y los listener son capas o escenas,
cocos puede encargarse del registro / desregistro:


 - Cuando una escena se activa, recorrerá el árbol de la escena para permitir a las capas el autoregistro de los eventos de director.window. El recorrido comienza por la escena, y se traslada solo a los hijos de clase layer.

 - Cuando es alcanzado por este recorrido, toda capa cuya variable de clase is_event_handler tenga un valor True, se registrará a si misma como listener de director.window.

   El registro será de la forma::

        director.window.push_handlers(layer)


   De forma que cada método cuyo nombre coincida con un <nombre de evento> será registrado como listener.

 - Cuando la escena se desactive (por medio de director.pop o director.replace por ejemplo), se iniciará el recorrido que coincida llamando::

        director.window.remove_handlers(layer)


Eventos generados propios de cocos:

    - (director, 'on_push')
    - (director, 'on_pop')
    - (director, 'on_resize')
    - (director, 'on_cocos_resize')

Cocos registra un listener de teclado que provee de funcionalidad muy útil,
ver :doc:`default_handlers`

.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html


