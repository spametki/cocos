Colisiones por Mapas
====================

Resumen
-------

Si una escena tiene un actor en movimiento, podríamos actualizar su posición
entre cuadros utilizando una aproximación discreta::

    velocity = velocity + acceleration * dt
    position = position + velocity * dt

Eso es correcto siempre y cuando el actor no encuentra un obstáculo, como una
pared.

Si hay un obstáculo, probablemente querramos

 - Detener el cambio de posición para que el actor toque el obstáculo pero
   no se superponga con el.
 - Realizar alguna acción importante con respecto a la velocidad (detener ?,
   rebotar ?) 
 - Quizás realizar alguna acción según cuál obstáculo se ha tocado (pinches ?,
   vidrio ?).

Para hacer esto podemos representar al actor y a los obstáculos como
rectángulos con lados paralelos los ejes, y hacer los cálculos.

Eso es lo que hacen los `map colliders` según:
 - La velocidad del actor, el el rectángulo previo y el rectángulo hipotético
   que le sigue.
 - un `map layer` que contiene una serie de obstáculos

hará lo siguiente
    - Actualizar correctamente la velocidad y la posición.
    - Invocar los métodos apropiados cuando detecte que el actor se ha topado
      con un obstáculo.
    - Determinar si alguna colisión en los ejes x o y ha ocurrido.

Si bien algunos `mapcolliders` están pensados para ser usados en mapas de
mosaicos (:class:`~.mapcolliders.RectMapCollider`,
:class:`.RectMapWithPropsCollider`), otros (:class:`.TmxObjectMapCollider`)
se pueden usar totalmente sin mosaicos.


Actualización correcta de la velocidad y la posición
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

La actualización de la posición y la velocidad se pueden escribir como::

    vx, vy = actor.velocity

    # usando los controles del jugador, la gravedad y otros factores de
    # aceleración, actualizar la velocidad
    vx = (keyboard[key.RIGHT] - keyboard[key.LEFT]) * actor.MOVE_SPEED
    vy += GRAVITY * dt
    if actor.on_ground and keyboard[key.SPACE]:
        vy = actor.JUMP_SPEED

    # con la velocidad actualizada calcular el desplazamiento hipotético
    dx = vx * dt
    dy = vy * dt

    # obtener el rectángulo actual con los límites del jugador
    last = actor.get_rect()

    # crear el rectángulo hipotético siguiente
    new = last.copy()
    new.x += dx
    new.y += dy

    # detectar los obstáculos alcanzados, esto ajustará los nuevos vx, vy
    actor.velocity = mapcollider.collide_map(maplayer, last, new, vx, vy)

    # actualizar el estado de on_ground
    actor.on_ground = (new.y == last.y)

    # actualizar la posición del jugador; la posición del jugador se ancla al
    # centro del rectángulo de la imagen
    actor.position = new.center

El cambio de la velocidad en una colisión es manejado por el método
:attr:`~.mapcolliders.RectMapCollider.on_bump_handler()`; este puede
establecerse con código personalizado o con uno de los manejadores
incorporados:

    - :meth:`~.mapcolliders.RectMapCollider.on_bump_bounce()`: Rebota cuando
      se toca una pared.
    - :meth:`~.mapcolliders.RectMapCollider.on_bump_stick()`: Detiene todo
      movimiento cuando se toca una pared. (sticky bomb ...).
    - :meth:`~.mapcolliders.RectMapCollider.on_bump_slide()`: Bloquea todo
      movimiento solo en el eje que tocó la pared. (jugador...).

Por comodidad, se puede especificar un manejador incorporado en el momento de
crear la instancia con el parámetro ``velocity_on_bump``.


Invocar métodos adecuados si se detecta que el actor se topó con un obstáculo
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Cuando ``mapcollider.collide_map`` detecta que un actor colisiona el objeto
'someobj' por el lado 'someside', llamará a 
``mapcollider.collide_<someside>(someobj)``.

Donde 'someside' es una opción entre 'left', 'right', 'top' y 'bottom'.

Esto da la oportunidad de hacer cosas según qué objeto tocó el actor, como por
ejemplo 'pinche' ? -> comenzar la animación de pinchar y matar al actor.

Ten en cuenta que cada ``mapcollider.collide_*`` puede recibir múltiples
llamadas en la misma llamada a ``mapcollider.collide_map``.


Determinar si ha ocurrido una colisión en los ejes x o y
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Una vez que ``collide_map`` finaliza, los indicadores ``mapcollider.bumped_x``
y ``mapcollider.bumped_y`` informan si ha habido alguna colisión a lo largo de
los ejes respectivos.

Esto puede ser útil para invertir la dirección de la animación del actor, por
ejemplo desde 'caminar_izquierda' a 'caminar_derecha'.


Variantes
---------

Actualmente hay tres formas de colisiones por mapas:

RectMapCollider
^^^^^^^^^^^^^^^

Los obstáculos son mosaicos rectangulares agrupados en :class:`.RectMapLayer`;
todas las celdas no vacías se consideran sólidas.

:class:`implementación <cocos.mapcolliders.RectMapCollider>`

RectMapWithPropsCollider
^^^^^^^^^^^^^^^^^^^^^^^^

Los obstáculos son mosaicos rectangulares agrupados en :class:`.RectMapLayer`,
las celdas usan las propiedades "left", "right", "top" y "bottom" para señalar
qué lado(s) bloquea(n) el movimiento.

Un bloque sólido probablemente tenga los cuatro lados habilitados; una
plataforma puede habilitar solo "top" para que el jugador pueda saltar desde
abajo y atravesarla.

Es conveniente que estas propiedades se configuren en los mismos mosaicos, en
lugar de hacerlo en celdas individuales. Por supuesto que en el caso de una
celda que es una entrada a un área secreta podrías sobreescribir las
propiedades de la pared para deshabilitar un lado y permitir el acceso.

Ver :ref:`cell_properties_label` para detalles sobre propiedades.

:class:`implementación <cocos.mapcolliders.RectMapWithPropsCollider>`


TmxObjectMapCollider
^^^^^^^^^^^^^^^^^^^^

Los obstáculos son :class:`.TmxObjects` agrupados en un
:class:`.TmxObjectLayer`, cada objeto tiene como propiedad bloquear el
movimiento.

Un uso típico es cuando se mueven plataformas en un juego de plataformas.

:class:`implementación <cocos.mapcolliders.TmxObjectMapCollider>`


Modo de uso
-----------

Existen básicamente dos modos de incluir esta funcionalidad en una clase actor:

    - como componente, básicamente pasando ((mapcollider, maplayer) en
      el método __init__ del actor.
    - estilo "mixin", usando :class:`~.mapcolliders.RectMapCollider` o una
      subclase como clase base secundaria para el actor.

El modo como componente es más ordenado mientras que el estilo "mixin" es más
potente ya que el código para las colisiones tendrá acceso a todo el actor a través
del atributo ``self``.

Para tener una instancia funcional, el comportamiento de la velocidad en una
colisión debe estar definido, y ese es el trabajo del método
``on_bump_handler``

    - si alguno de los ``on_bump_<variante>`` cumple con los requerimientos,
      basta con escribir::
      
        mapcollider.on_bump_handler = mapcollider.on_bump_<variante elegida>

      o pasando un selector en el momento de creación de la instancia::
      
        mapcollider = MapCollider(<variante elegida>)

    - para un comportamiento personalizado define ``on_bump_handler`` en una
      subclase y crea una instancia de ella.
