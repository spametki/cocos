Colisiones﻿
===========

.. contents::
    :local:

Modelo de colisiones
--------------------

Usos posibles
^^^^^^^^^^^^^

Es típico consultar sobre una u otra relación espacial entre actores, por ejemplo

	- ¿algún enemigo está tocando a un jugador?
	- ¿algún jugador está cerca de un enemigo o a algo que genere una acción?
	- ¿cuál enemigo está más cerca del jugador?
	- ¿algún actor está bajo el puntero del mouse?

El módulo collision_model tiene los elementos necesarios para responder estas preguntas,
veamos cómo funciona. 

Siluetas simplificadas
^^^^^^^^^^^^^^^^^^^^^^

Los actores por lo común tienen una silueta irregular, entonces para responder '¿A está tocando a B?' se debería chequear cada pixel de los dos actores. Eso sería demasiado lento, así que cada actor especifica una figura geométrica simple a usarse para la detección de colisiones,
y la pregunta se transforma en '¿la silueta del actor A se superpone con la del actor B?'

Las formas disponibles hasta el momento son los círculos (disc) y rectángulos con lados paralelos a los ejes x=0 e y=0.

¿Qué debe cumplir un objeto para ser colisionable?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	- debe tener un elemento .cshape
	- el valor del elemento .cshape es instancia de :class:`~cocos.collision_model.CircleShape` o de :class:`~cocos.collision_model.AARectShape`
 
Ejemplos::

	import cocos.euclid as eu
	import cocos.collision_model as cm
	
	class CollidableSprite(cocos.sprite.Sprite):
		def __init__(self, image, center_x, center_y, radius):
			super(ActorSprite, self).__init__(image)
			self.position = (center_x, center_y)
			self.cshape = cm.CircleShape(eu.Vector2(center_x, center_y), radius)
	
	class ActorModel(object):
		def __init__(self, cx, cy, radius):
			self.cshape = cm.CircleShape(eu.Vector2(center_x, center_y), radius)
			
El rol del administrador de colisiones
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Las preguntas como '¿Qué actores están cerca de A?' asumen en forma implícita que un conjunto de candidatos a probar se ha definido previamente. Aquí es donde aparece la instancia de CollisionManager: ella almacena un registro de qué objetos colisionables están
próximos y pueden colisionar. Al ser el objeto que conoce los candidatos, es el que se encargará de responder preguntas acerca
de relaciones espaciales entre un colisionable y sus colisionables próximos.  

Para administrar el conjunto de candidatos conocidos están los siguientes métodos

    - add(obj) : hace que obj sea un colisionable reconocido por la instancia de CollisionManager
    - remove_tricky(obj) : hace que la instancia de CollisionManager olvide a obj; para que funcione obj.cshape debe ser igual que al llamar .add(obj) 
    - clear() : la instancia de CollisionManager olvidará todos los objetos conocidos
	
Para pruebas y depuración están disponibles los métodos ´knows(obj)´ y ´known_objs()´.

Una respuesta correcta depende de si los objetos conocidos tienen el mismo valor cshape al consultar y al agregarse.
Para satisfacer esta restricción hay dos estrategias típicas.

    - hacer collision_manager.remove_tricky(obj); obj.update_cshape(); collision_manager.add(obj) cada vez que obj requiere actualizar su valor de cshape. Esto es relativamente lento, pero aceptable si son pocos los colisionables que necesitan actualizar su cshape en cada cuadro.

    - en cada cuadro hacer::

        collision_manager.clear()
        actualizar el cshape para todo colisionable
        agregar todos los colisionables al collision_manager 
        utilizar la misma lógica para la colisión de actores


      Este patrón es adecuado cuando la mayor parte de los actores cambian el cshape en cada cuadro.

A veces puede valer la pena el uso de dos instancias del administrador de coliciones: una para actores que rara vez cambian el cshape (rocas, comida, ...) y otra para objetos que actualizan su cshape en cada cuadro (jugadores, monstruos, ...)


Limitaciones y debilidades
^^^^^^^^^^^^^^^^^^^^^^^^^^

Este es posiblemente el esquema más sencillo para lidiar con colisiones y proximidad.
El código y la API son simples y fáciles de modificar.
Las desventajas son bien conocidas.

    - las colisiones para muy pequeños o muy rápidos objetos pueden pasarse por alto
    - no es adecuado para rebotes realistas

Más detalles
^^^^^^^^^^^^

Ver :class:`~cocos.collision_model.CollisionManager` y :class:`~cocos.collision_model.Cshape` para más detalles; Para los parámetros de __init__ ver la implementación correspondiente.

Datos de rendimiento
--------------------

La prueba de rendimiento
^^^^^^^^^^^^^^^^^^^^^^^^

La prueba de rendimiento mueve cierta cantidad de bolas en un área rectangular, con rebote suave en las interacciones bola-bola y bola-borde. Se mide el tiempo para calcular una cantidad preestablecida de cuadros sin generar los gráficos; esto da el tiempo en función de los cálculos físicos por cuadro. Las posiciones iniciales se eligen en forma aleatoria en el rectángulo, y la velocidad inicial tiene ángulo aleatorio uniforme. Lo más probable es que las bolas tengan una distribución uniforme en el rectángulo.

El código fuente del modelo de entorno se ha colocado en benchmarks/collision/a0_bouncing_balls_Model.py, y el motor en benchmarks/collision/a0_benchmark_time_per_frame.py

Al ejecutar directamente el script del modelo se muestra en pantalla con el detalle de cuadros por segundo.

Testbed: windows xp sp3 32 bits, python 2.6.5,
AMD athlon dual core 5200+, memory DDR2 800 single channel

Comparando con fuera bruta
^^^^^^^^^^^^^^^^^^^^^^^^^^

Se ha creado una prueba de rendimiento para comparar el método de fuerza bruta con otras implementaciones
Actualmente la única implementación de CollisionManager es CollisionManagerGrid, que acepta parámetros para definir el tamaño de celdas; la figura compara la duración por cuadro para fuerza bruta y CollisionManagerGrid con distintos tamaños de celdas.

.. image:: comparing_collision_managers.png
   :align: center
   :width: 500px
   :height: 600px
   

Comparación por silueta
^^^^^^^^^^^^^^^^^^^^^^^

La prueba de rendimiento se puede personalizar con parámetros según la implementación de Cshape que se utilice; aquí se comparan círculos vs AABB

.. image:: comparing_shapes.png
   :align: center
   :width: 500px
   :height: 600px

Cuadros por segundo en Ballpark
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

La visualización provista con a0_bouncing_balls_Model.py, que muestra todas las bolas y un rectángulo coloreado corre a 60 fps con 165 bolas, y 30fps con 300 bolas (gpu ati radeon 4650)
