CocosNodes
==========

.. contents::
    :local:

Propiedades de CocosNode
------------------------

El hecho de que todos los objetos que construyen la escena sean subclases de CocosNode da cuenta de cómo comparten un núcleo de
características y funcionalidades. Conocer a uno basta para conocer a todos.

El núcleo común se puede dividir por funcionalidad en


Padre-hijo
^^^^^^^^^^

    - .add(self, child, z=0, name=None ): Agrega un hijo, genera una excepción de nombre duplicado si lo hubiera
    - .remove(self, name_or_obj): Elimina un hijo según el nombre u objeto como parámetro. Genera una excepción de hijo no
      encontrado en caso de no existir
    - .kill(self): Se elimina a sí mismo del padre
    - .parent: propiedad que devuelve el nodo padre o None
    - .get_ancestor(self, klass): Devuelve el primer ancestro que sea instancia de klass, o None
    - .get_children(self): Devuelve una lista de hijos, con orden de atrás hacia adelante (ascendente en z)
    - .get(self, name): Obtiene un hijo según su nombre, genera una excepción de hijo no encontrado de no existir
    - operador in, como en 'node1 in node2': devuelve True si y solo si node1 es hijo de node2

`Ejemplos de padre-hijo`_

Ubicación espacial
^^^^^^^^^^^^^^^^^^

La posición de un nodo se define relativa a su nodo padre, más precisamente respecto de la posición del padre.

    - .x, .y .position: propiedades que devuelven la posición relativa al origen del padre; al actualizar x o y automáticamente actualiza la posición. A la inversa también se cumple.
    - .anchor_x, .anchor_y, anchor: propiedades que devuelven el centro para cambio de tamaño y rotación, automáticamente mantienen la relación anchor == (anchor_x, anchor_y). Nótese que distintas subclases de CocosNode pueden tener distintos valores por defecto para anchor.
    - .scale : 1.0 es el tamaño por defecto, con 2.0 el nodo duplicará su tamaño visible.
    - .scale_x, .scale_y : coeficientes de cambio de tamaño por eje. El coeficiente total en el eje x es .scale * scale_x, y otro tanto para el eje y
    - .rotation : rotación en grados

`Muestras de Ubicación Espacial`_ ; además muchos de los script en el directorio tests hacen ubicación explícita.

Entrando o Saliendo de la Escena Activa
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    - .on_enter(self): actúa cuando se agrega a un objeto padre si el padre pertenece a la escena activa o si toda la escena se activa
    - .on_exit(self): actúa cuando se elimina un objeto del padre en la escena activa o si toda la escena se desactiva

    
Conversión Gráfica (Rénder)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    - .visit(self): hace rénder de sí mismo y sus hijos. El orden de rénder es hijos con z <= 0, el objeto en sí, hijos con z > 0
    - .draw(self): se dibuja a sí mismo
    - .transform(self): ayudante para draw y visit, maneja los cambios de coordenadas de OpenGL necesarios para el rénder según posición, anclaje, tamaño y rotación
    - .camera: en lugar de las usuales posición, anclaje, tamaño y rotación utiliza un gluLookAt especial que también admite z. Esto se usa en raras ocasiones, por lo común en efectos especiales para transiciones.

    
Manejo del tiempo
^^^^^^^^^^^^^^^^^

    - .schedule_interval(self, callback, interval, \*args, \*\*kwargs): Programa una función para que sea llamada cada cantidad de segundos especificados en interval.
    - .schedule(self, callback, \*args, \*\*kwargs): Programa una función que sea llamada en cada cuadro.
    - .unschedule(self, callback): Elimina una función programada.
    - .pause_scheduler(self): El tiempo dejará de transcurrir para este nodo: las funciones programadas no se llamarán, las acciones de rutinas tampoco
    - .resume_scheduler(self): El tiempo correrá o seguirá corriendo y se activarán las funciones programadas y las acciones de rutinas


Cambios automatizados a lo largo del tiempo (manejo de acciones)    

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    - .do(self, template_action, target=None): la mayoría de las veces se lo llama con target=None, que da como resultado que target sea self. La acción realizará un cambio gradual en principio sobre target. Devuelve la acción de rutinas, que es el objeto que hace los cambios. Debes guardar una referencia a la rutina su planeas llamar más adelante a .action_remove
    - .action_remove(self, worker_action): finalizará la acción de rutinas
    - .pause(self): Suspende la ejecución de acciones.
    - .resume(self): Continua la ejecución de acciones.
    - .stop(self): Todas las acciones en este nodo se eliminan, el método stop será llamado para cada acción.
    - .are_actions_running(self): Informa si hay acciones corriendo. Devuelve True o False

Los cambios automatizados son realizados en conjunto entre instancias de :class:`~cocos.cocosnode.CocosNode` y :class:`Action`

`Ejemplos de cambios automatizados en el tiempo`_

Además el directorio test tiene muchos ejemplos como test_accel*.py, test_blink.py, test_callfunc*.py y otros.


Breve recorrido por las subclases incorporadas de CocosNodes
------------------------------------------------------------

Scene
^^^^^

La raiz del árbol que representa el total del contenido a mostrar.
Para intercambiar escenas se usa el director.

Referencias: :ref:`guía de Scene<guide_scene>` , :class:`api de Scene<cocos.scene.Scene>`


TransitionScene
^^^^^^^^^^^^^^^

Clase base para implementar un cambio gradual entre pantallas (escenas). Los ejemplos típicos son el fundido a negro
y su inversa (fade in y fade out).

Cocos viene con un montón de transiciones entre escenas listas para usar (el código de ejemplo está en test/test_transition_*.py)

Referencias: :class:`api de Scene <cocos.scenes.transitions.TransitionScene>`


Layer
^^^^^

Ayuda en la organización de la vista en el eje de la profundidad.
Sus subclases a menudo ofrecen servicios especiales para sus hijos (como ScrollingManager), y se puede utilizar para crear funcionalidades de un orden superior (como Menu)

Referencias: :ref:`guía de Layer<guide_layer>` , :class:`api de Layer<cocos.layer.base_layers.Layer>`

ColorLayer
^^^^^^^^^^

El uso principal es el de proveer de un color sólido al fondo de la escena, además se usa para dibujar rectángulos de color sólido.

Referencias: :class:`api de ColorLayer<cocos.layer.util_layers.ColorLayer>`

MultiplexLayer
^^^^^^^^^^^^^^

Permite mostrar solo uno de sus hijos, y elegir cuál mostrar.
Un caso de uso es cuando quieres mostrar solo uno de un grupo de menús.

Referencia: :class:`api de MultiplexLayer<cocos.layer.base_layers.MultiplexLayer>`

ScrollingManager
^^^^^^^^^^^^^^^^

Coordina un número de ScrollableLayer para que desplace haciendo ajustes (paralaje) de manera que el desplazamiento no se vaya afuera del entorno.

Referencia: :class:`api de ScrollingManager<cocos.layer.scrolling.ScrollingManager>`

ScrollableLayer
^^^^^^^^^^^^^^^

Usado como hijo de ScrollingManager, ayuda a manejar los límites de desplazamiento y paralaje.
Debes establecer los atributos px_width y px_height en una instancia de `ScrollableLayer` para que las restricciones en el desplazamiento tengan efecto.
Si se usa paralaje, este debe estar especificado en el constructor.

Referencia: :class:`api de ScrollableLayer<cocos.layer.scrolling.ScrollableLayer>`

RectMapLayer y HexMapLayer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Un mapa de mosaicos es una descripción del entorno donde
 - el espacio está dividido en una grilla regular (rectangular u hexagonal en cocos)
 - se conoce qué imagen asociada y cuáles propiedades del juego tiene cada celda de la grilla.

`RectMapLayer` y `HexMapLayer` son usualmente generados por tiles.load, y se encargan de mostrar el entorno y proveer de acceso a las propiedades de las celdas.

Los ejemplos se encuentran en test/test_tiles.py y test/test_platformer.py

Referencia: :class:`api de RectMapLayer<cocos.tiles.RectMapLayer>` , :class:`api de HexMapLayer<cocos.tiles.HexMapLayer>`

PythonInterpreterLayer
^^^^^^^^^^^^^^^^^^^^^^

Es usado por el director para mostrar una consola de python que permite inspeccionar y modificar los objetos en la aplicación que usen al director.
No debes crear manualmente una instancia de PythonInterpreterLayer, simplemente presiona ctrl + i (cmd + i en mac) para mostrar u ocultar la capa del intérprete.

Referencia: :doc:`guía de PythonInterpreterLayer<interpreter>` , :class:`api de PythonInterpreterLayer<cocos.layer.python_interpreter.PythonInterpreterLayer>`

Sprite
^^^^^^

Los sprite permiten mostrar una imagen en un área rectangular, que se puede rotar,
cambiar de tamaño y mover.

Referencia: :class:`api de Sprite<cocos.sprite.Sprite>`


Animación de un sprite
++++++++++++++++++++++

La animación al estilo de los dibujos animados, es decir, el reemplazo de la
imagen lo suficientemente rápido para dar la ilusión del movimiento, se puede
lograr por:

- el uso de un .gif animado como origen de la imagen
- el uso de un elemento pyglet.image.Animation como imagen, que consiste en una serie de imágenes
- el uso de un arreglo con varias imágenes y código que asigne distintos elementos del arreglo a la propiedad image del sprite

Consideraciones sobre rendimiento
+++++++++++++++++++++++++++++++++

Los sprite no son adecuados para efectos que incluyan numerosas imágenes
semitransparentes para convertirlas en gráficos como en el humo o la niebla
venenosa. En ese caso hay que usar sistemas de partículas u objetos CocosNode
personalizados que puedan manejar listas de vértices.

Si tu escena tiene menos de 25 sprite, puedes agregarlos directamente a la
escena, de esta forma::

    class TLayer(cocos.layer.Layer):
        is_event_handler = True
        def __init__(self):
            cocos.layer.Layer.__init__(self)
            world_width, world_height = director.get_window_size()
            rand_color = [255, 0, 0]
            icolor = 0
            for i in range(qty_balls):
                ball = Ball((world_width*random.random(), world_height*random.random()), color=rand_color)
                rand_color[icolor] = random.randint(50, 255)
                icolor = (icolor + 1)%len(rand_color)
                self.add(ball)
    self.time = 0.0
    self.schedule(self.update)

Si tienes entre 25 y 100 sprite visibles, en movimiento en cada cuadro,
deberías agregar uno o más objetos BatchNode según haga falta en la escena
y asignarles los sprite. Incluso un solo BatchNode te puede cuadruplicar los
cuadros por segundo::

    class TLayer(cocos.layer.Layer):
        is_event_handler = True
            def __init__(self):
                cocos.layer.Layer.__init__(self)
                batch = cocos.batch.BatchNode()
                self.add(batch) # agregamos un batch a la capa ...
                world_width, world_height = director.get_window_size()
                rand_color = [255, 0, 0]
                icolor = 0
                for i in range(100):
                    ball = Ball((world_width*random.random(), world_height*random.random()), color=rand_color)
                    rand_color[icolor] = random.randint(50, 255)
                    icolor = (icolor + 1)%len(rand_color)
                    batch.add(ball) # ves ? se asignan los sprite al batch, no a la capa
                self.batch = batch
                self.time = 0.0
                self.schedule(self.update)

Con más de 100 visibles, al mover los sprite en cada cuadro, necesitarás
mayor optimización para que la aplicación corra a 60 fps en un equipo limitado,
como una notebook, máquinas de escritorio viejas o de bajo costo.
Para más ejemplos puedes consultar los sistemas de partículas de cocos y
la sección de gráficos de la guía del programador de pyglet.

Con la prueba ballpark, una máquina de bajas especificaciones para juegos (athlon 5200, radeon 4650) da estos resultados::

    numballs    fps
        250     98
        500     54
        750     36

Ten en cuenta que los sprite fuera de la vista representan una parte menor del costo de los sprite visibles: ellos son descartados en el momento del cálculo geométrico de openGL (en la mayoría de las implementaciones de openGL)

    
Sistemas de Partículas
^^^^^^^^^^^^^^^^^^^^^^

Algunos efectos se convierten mejor como un gran número de imágenes coloreadas y semitransparentes, por ejemplo las explosiones y el humo.
Cocos viene con una clase base :class:`~cocos.particle.ParticleSystem` que convierte eficientemente esos elementos, y algunas subclases
especializadas en el módulo :mod:`cocos.particle_systems` como `Fireworks`, `Spiral`, `Meteor`, `Sun`, `Fire`, `Galaxy`, `Flower`, `Explosion` y `Smoke`.

El método más común para personalizar sistemas de partículas es el de crear una subclase de uno de los sistemas de partículas y modificar algunos de los elementos de la clase que definen su comportamiento.
Si modificas la textura de la partícula recuerda cargarla con pyglet.image.load, no con pyglet.resource.image
Por supuesto, una mejor personalización se logra creando sublcases y personalizando el código. 
If you change the particle texture remember to load it with pyglet.image.load, not pyglet.resource.image
Of course, deeper customization can be achieved with subclassing and code customization.

Consulta test/test_particle_*.py para código de ejemplo.

TextElement, Label, HTMLLabel, RichLabel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Todas las clases admiten opacidad promedio, familia y tamaño de fuente.

:class:`~cocos.text.TextElement`: clase base para todo texto en cocos. Mantiene internamente (propiedad 'element') un objeto de texto de
pyglet apropiado, que provee tanto la interfaz CocosNode como el Batch de pyglet para almacenar partes.
Otras funcionalidades excepto opacidad y las que corresponden a cocosnode deben ser manejadas a través de instancia.element.

:class:`~cocos.text.Label`: produce el texto más simple; también permite establecer el color.
 
:class:`~cocos.text.HTMLLabel`: un tipo de Label más potente, soporta mezcla de estilos. Usa la sintaxis de HTML para el texto y los estilos; permite configurar la opacidad (para todo el texto).

:class:`~cocos.text.RichLabel`: Permite el uso de propiedades de texto enriquecido.

Hay más ejemplos en test/test_label_*.py, test/test_htmllabel_*.py y test/test_rich_label.py

Menu
^^^^

- Organiza la presentación de los elementos del menú
- Maneja la exploración entre elementos del menú
- Establece qué animación se debe reproducir cuando el foco cambia entre un elemento del menú y otro

Ejemplos en test/test_menu_*.py

Referencia: :class:`~cocos.menu.Menu`
 
Elementos del Menú
^^^^^^^^^^^^^^^^^^

:class:`~cocos.menu.MenuItem`: Un elemento del menú que muestra un texto

:class:`~cocos.menu.ImageMenuItem`: Elemento del menú que muestra una imagen y opcionalmente texto

:class:`~cocos.menu.MultipleMenuItem`: Permite recorrer una lista configurable de opciones

:class:`~cocos.menu.ToggleMenuItem`: Muestra una opción de encendido/apagado

:class:`~cocos.menu.EntryMenuItem`: Muestra una etiqueta y un campo para introducir texto

:class:`~cocos.menu.ColorMenuItem`: Permite elegir un color

Look at test/test_menu_items.py for sample code.

Creando tus propias subclases de CocosNode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO: explicar cómo construir objetos cocosnode personalizados, como usar
`transform`, etc.

Ejemplos de CocosNodes
----------------------

Ejemplos de padre-hijo
^^^^^^^^^^^^^^^^^^^^^^

Construcción de una escena, la creación de la instancia se omite::

    # una escena con 2 capas; el fondo se vería detras de la capa del juego por los valores de z
    scene.add( background_layer, z=0 )
    scene.add( game_layer, z=1 )

    # la capa con un un sprite de bloody pacman
    bloody_pacman_sprite.position = (100, 100)
    game_layer.add( bloody_pacman_sprite )

    # el bloody pacman tiene dos cuchillos !!!
    sprite.add( dagger_far_sprite, z=-1 )
    sprite.add( dagger_near_sprite, z=1  )
    # el orden en que se dibujan es dagger_far, bloody_pacman, dagger_near

    # también hay alien zombie cowboy en el juego,
    # así que agregamos algunos de ellos a la capa game_layer
    ...
 
Un cuchillo ha tocado a un alien zombie cowboy así que debemos crear una fea
mancha de sangre verde. Podríamos agregar el blotch_sprite al zac_sprite, para
que la mancha siga al zombie::

    zac_zprite.add(blotch_sprite, z = 1)

o podríamos agregarla a la capa game_layer, y la mancha no seguiría al zombie::

    layer = zac_sprite.parent # debería ser game_layer
    layer.add(blotch_sprite)

Si por alguna ridícula razón un cuchillo necesitara mantener una referencia con
la capa game_layer podríamos usar 'get_ancestor'.
Por la forma en que distribuimos la escena, sabemos que game_layer es padre de
bloody_pacman_sprite, que es padre de dagger. Entonces::

    layer = dagger_near.get_ancestor(Layer)

tendría que resultar en game_layer.

Han matado a un zombie, podemos salir de la escena con::

    zac_sprite.kill()

o con::

    game_layer.remove(zac_sprite)

o si lo hemos llamado "T'chkss" al agregarlo al game_layer, de esta forma::

    game_layer.add(zac_sprite, name = "T'chkss", z=4)

entonces podemos removerlo con::

    game_layer.remove("T'chkss")

Ten en cuenta que en el cocos actual si agregas usando un nombre debes remover
usando también un nombre, de lo contrario el nombre no estará disponible en
nuevas adiciones.

Muestras de Ubicación Espacial
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Ejemplo::

    # colocar el sprite en 320,240
    sprite.position = (320,240)

o utilizando acciones.
Ejemplo::

    # mover el sprite a 320,240 con una duración de 5 segundos
    sprite.do( MoveTo( (320,240, duration=2 ) )

Ejemplos de cambios automatizados en el tiempo
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
Puedes modificar los atributos de cualquier objeto `CocosNode`.
Por ejemplo::

    scene.do( ScaleTo(2, duration=2) )

    layer.do( RotateBy(360, duration=3) )

    sprite.do( Blink(5, duration=1 ) )

    label.do( JumpBy( (100,100), 50, 5, duration=3) )
