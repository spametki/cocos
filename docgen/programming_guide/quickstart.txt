Creando una aplicación en cocos2d
=================================

Comenzar con una nueva librería o framework puede ser complicado, especialmente
si la librería viene con una documentación de referencia extensa para leer. Este
capítulo da una rápida introducción a cocos2d sin detenerse en los detalles.

.. contents::
    :local:

Hola, Mundo
-----------

Comenzaremos con la clásica introducción del "Hola, Mundo". Este programa abrirá
una ventana que incluye un texto y espera a ser cerrada. Puedes encontrar el
programa completo en el archivo `samples/hello_world.py`.

.. image:: hello_world.py.png

Comienza importando el paquete cocos::

    import cocos

Crea una subclase de `Layer` (capa) y define la lógica de tu programa aquí::

    class HelloWorld(cocos.layer.Layer):

Siempre debes invocar a ``super`` en el constructor::

    def __init__(self):
        super(HelloWorld, self).__init__()

Para mostrar el texto, crearemos una etiqueta (`Label`). Los keyword argument
(parametros tipo a=b) se usan para establecer la fuente, la posición y alineación
de la etiqueta::

    label = cocos.text.Label(
        'Hello, world',
        font_name='Times New Roman',
        font_size=32,
        anchor_x='center', anchor_y='center'
    )

La posición de la etiqueta será el centro de la pantalla::

    label.position = 320, 240

Como `Label` es una subclase de `CocosNode`, se la puede agregar como hijo. Todos
los objetos `CocosNode` saben como mostrarse en pantalla (render), realizar
acciones y transformaciones.
Para agregarla como hija de una capa, utiliza el método `CocosNode.add`::

        self.add(label)

Después de definir la clase ``HelloWorld``, necesitamos inicializar y crear una ventana.
Para ello, inicializamos el `Director`::

    cocos.director.director.init()

Entonces creamos la instancia ``HelloWorld``::

    hello_layer = HelloWorld()

Ahora creamos una escena (`Scene`) que contenga la capa ``HelloWorld`` como hija::

    main_scene = cocos.scene.Scene (hello_layer)

Y por último corremos la escena::

    cocos.director.director.run(main_scene)

Una forma abreviada de escribir las últimas 3 instrucciones es esta::

    cocos.director.director.run(cocos.scene.Scene(HelloWorld()))


Hola Acciones
-------------

.. figure:: hello_world_actions.py.png

Este es un ejemplo muy parecido al primero, pero con la diferencia que nos presenta
el mundo de las acciones (Actions).
Una acción es como una órden. Puedes decirle a cualquier objeto `CocosNode` que
realice una acción.
Puedes encontrar el programa completo en el archivo `samples/hello_world_actions.py`.


Como en nuestro ejemplo anterior, importamos el paquete cocos::

        import cocos

Si vas a usar muchas acciones, puedes importar todas las
disponibles al namespace con este comando::

    from cocos.actions import *

Creamos una subclase de `ColorLayer` (capa de color) para tener un color de fondo,
y luego llamamos a super() con un color azulado::

    class HelloWorld(cocos.layer.ColorLayer):
        def __init__(self):
            # color azulado
            super( HelloWorld, self ).__init__( 64,64,224,255)

Como en el ejemplo anterior, creamos una etiqueta::

    label = cocos.text.Label('¡Hola, Mundo!',
        font_name='Times New Roman',
        font_size=32,
        anchor_x='center', anchor_y='center')

    # ubica a la etiqueta en el centro de la pantalla
    label.position = 320,240
    self.add( label )

En este ejemplo además creamos y agregamos un sprite (elemento gráfico) como hijo.
En cocos2d los sprite son objetos `Sprite`::

    sprite = cocos.sprite.Sprite('grossini.png')

Colocamos el sprite en el centro de la imagen. La posición por defecto es (0,0)::

    sprite.position = 320,240

Establecemos el atributo scale (escala) en 3. Esto significa que nuestro sprite
será 3 veces más grande. El valor de escala por defecto es 1::

    sprite.scale = 3

Agregamos el sprite como hijo pero por sobre la etiqueta definiendo el valor z en 1, ya
que el valor de z por defecto es 0::

    self.add( sprite, z=1 )

Creamos una acción `ScaleBy`. Esta acción agrandará el objeto 3 veces en dos segundos::

    scale = ScaleBy(3, duration=2)

Hacemos que la etiqueta:

 1. se agrande al triple en 2 segundos
 2. que se haga 3 veces más chico en 2 segundos
 3. y repetimos estas dos acciones continuamente

Ten en cuenta que el operador '+' es la acción `Sequence`::

    label.do( Repeat( scale + Reverse( scale) ) )

Y le decimos al sprite que haga lo mismo que la etiqueta pero comenzando por el achicamiento::

    sprite.do( Repeat( Reverse(scale) + scale ) )

Ahora inicializamos el director, como en el ejemplo anterior::

    cocos.director.director.init()
    hello_layer = HelloWorld ()

Y... le decimos a la capa (sí, todos los objetos `CocosNode` pueden realizar acciones) que 
ejecute una acción `RotateBy` (rotación en el tiempo) de 360 grados en 10 segundos.

    hello_layer.do( RotateBy(360, duration=10) )

Finalmente arrancamos a la ejecución::

    # Una escena que contiene la capa hello_layer
    main_scene = cocos.scene.Scene (hello_layer)

    # Y ahora, arrancar la aplicación, comenzando por main_scene
    cocos.director.director.run (main_scene)


Controlando Eventos
-------------------

Todos nuestros ejemplos anteriores no tienen interactividad. Muestran algo, pero no responden
a acciones del usuario (salvo cuando cierras la aplicación al presionar **ESC** o
cerrar la ventana). Cocos recibe las acciones del usuario escuchando al director. Los eventos
de ventanas y, convenientemente, cocos.layer pueden automaticamente escuchar los eventos de
director.window: en tu subclase de Layer define el elemento de clase is_event_handler a True y
cocos se ocupará del resto.

En esta sección crearemos paso a paso la demo que viene en `samples/handling_events.py`; esta
es una aplicación de cocos muy simple que muestra cuáles son las teclas que se presionan, y
responde al movimiento del mouse y a los clic. Corre la app antes de continuar leyendo para
tener una noción mejor de lo que estamos intentando hacer.


.. figure:: event_demo.py.png

Esta demo tiene una escena con dos capas; una muestra cuáles son las teclas actualmente
presionadas (ninguna, una, o quizá muchas al mismo tiempo), la otra muestra texto con la
posición del puntero, y al cliquear mueve el texto.

Comenzamos definiendo la clase de capa KeyDisplay. Como siempre, agregamos alguna
inicialización en ``__init__`` y el código para mostar las teclas cada vez que se presionan::

        class KeyDisplay(cocos.layer.Layer):

            # si quieres que tu capa reciba los eventos de director.window
            # debes establecer esta variable como 'True'
            is_event_handler = True

            def __init__(self):

                super( KeyDisplay, self ).__init__()

                self.text = cocos.text.Label("", x=100, y=280 )

                # Para controlar qué teclas se presionan
                self.keys_pressed = set()
                self.update_text()
                self.add(self.text)

            def update_text(self):
                key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
                text = 'Keys: '+','.join (key_names)
                # actualizar self.text
                self.text.element.text = text

Esta clase define el conjunto (set) key_pressed, que debería contener las teclas
presionadas en cualquier momento. Sin embargo, este código por sí mismo todavía no hace
nada. Necesitamos decirle a esta capa que actualice el set cuando cada vez que se presione o
que se suelte una tecla. Dicho de otro modo, necesitamos agregar manejadores de eventos
(event handlers) a la capa. Para agregar un manejador de eventos a una capa basta con
agregarle métodos que se llamen on_<nombre del evento>. Los dos eventos que nos interesan
en este momento son ``on_key_pressed`` y ``on_key_release``::

        def on_key_press (self, key, modifiers):
            """Se llama a esta función cuando se presionó una tecla.
            'key' es una constante que indica qué tecla fue presionada
            'modifiers' es una operación binaria 'o' con varias constantes
            indicando qué modificadores (modifiers) estaban activos en forma
            simultánea cuando se presionó la tecla (ctrl, shift, capslock, etc.)
            """

            self.keys_pressed.add (key)
            self.update_text()

        def on_key_release (self, key, modifiers):
            """Se llama a esta función cuando se suelta una tecla.

            'key' es una constante que indica cuál tecla se soltó.
            'modifiers' es una operación binaria 'o' con varias constantes
            indicando qué modificadores (modifiers) estaban activos en forma
            simultánea cuando se presionó la tecla (ctrl, shift, capslock, etc.)
            Las constantes son las mismas que en pyglet.window.key
            """

            self.keys_pressed.remove (key)
            self.update_text()

        def update_text(self):
            key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
            text = 'Keys: '+','.join (key_names)
            # actualizar self.text
            self.text.element.text = text

Con ese código, la capa queda funcionando perfectamente. Puedes presionar y soltar
teclas o combinaciones de letras, y podrás ver cómo la pantalla se actualiza indicando
en cada momento qué teclas se presionan.

El manejo de eventos del mouse es similiar. Tienes tres eventos de interés: on_mouse_press,
on_mouse_motion y on_mouse_drag (clic, movimiento y arrastrar), con eso podemos definir
nuestra capa::

        class MouseDisplay(cocos.layer.Layer):

            is_event_handler = True     #: habilita los eventos de director.window

            def __init__(self):
                super( MouseDisplay, self ).__init__()

                self.posx = 100
                self.posy = 240
                self.text = cocos.text.Label('Sin eventos de mouse por ahora', font_size=18, x=self.posx, y=self.posy )
                self.add( self.text )

            def update_text (self, x, y):
                text = 'Mouse @ %d,%d' % (x, y)
                self.text.element.text = text
                self.text.element.x = self.posx
                self.text.element.y = self.posy

Y ahora agregamos manejadores de eventos para actualizar el texto cuando se mueva el mouse,
y cambiar la posición del texto cuando se hace clic con cualquier botón::

    def on_mouse_motion (self, x, y, dx, dy):
        """Se llama cuando el mouse se desplaza por la ventana de la aplicación
        sin hacer clic

        (x, y) son las coordenadas físicas del mouse
        (dx, dy) es el vector distancia cubierto por el puntero del mouse desde
        la última llamada
        """
        self.update_text (x, y)

    def on_mouse_drag (self, x, y, dx, dy, buttons, modifiers):
        """Se llama cuando el mouse se mueve sobre la ventana de la aplicación haciendo
        clic con cualquier botón o botones
        
        (x, y) son las coordenadas físicas del mouse
        (dx, dy) es el vector distancia cubierto por el puntero del mouse desde la última
        llamada.
        'buttons' es una operación binaria 'o' con las constantes en pyglet.window.mouse
        LEFT, MIDDLE, RIGHT
        'modifiers' es una operación binaria 'o' de las constantes de modificador en
        pyglet.window.keys (valores como 'SHIFT', 'OPTION', 'ALT')
        """
        self.update_text (x, y)

    def on_mouse_press (self, x, y, buttons, modifiers):
        """Se llama a esta función cuando se hizo clic

        (x, y) son las coordenadas físicas del mouse
        'buttons' es una operación binaria 'o' con las constantes en pyglet.window.mouse
        LEFT, MIDDLE, RIGHT
        'modifiers' es una operación binaria 'o' de las constantes de modificador en
        pyglet.window.keys (valores como 'SHIFT', 'OPTION', 'ALT')
        """
        self.posx, self.posy = director.get_virtual_coordinates (x, y)
        self.update_text (x,y)

Lo único un poco inusual aquí es la llamada a `director.get_virtual_coordinates` (x, y). Como se
explicó en el ejemplo anterior, cocos tiene dos sistemas de coordenadas, uno físico y otro virtual.
Los manejadores de eventos del mouse reciben sus argumentos de pyglet en coordenadas físicas. Si
quieres mapearlas a coordenadas virtuales, necesitas utilizar el método director.get_virtual_coordinates,
que hace el mapeado correctamente. En cambio si haces ``self.posx, self.posy = x, y`` en el manejador
on_mouse_press de arriba, verás que la aplicación parece funcionar, pero si cambias el tamaño de la ventana,
los clic harán mover el texto al lugar equivocado.

Para completar, hay otros eventos del mouse que pueden ser de interés:
    on_mouse_release : se llama cuando se suelta un botón
    on_mouse_scroll : se llama cuando se mueve la ruedita del mouse
    on_mouse_leave : se llama cuando el puntero sale del área de la ventana
    on_mouse_enter : se llama cuando el puntero del mouse entra en el área de la ventana

La demo no tiene mucho más código, excepto el necesario para crear una escena con estas dos capas y
correrla::

        director.init(resizable=True)
        # Correr una escena con nuestros monitores de eventos:
        director.run( cocos.scene.Scene( KeyDisplay(), MouseDisplay() ) )

Ahora puedes jugar con la demo y cambiarla. Algunas cosas que se pueden intentar son:

 * Cambiar el manejador on_mouse_press y eliminar el mapeo a coordenadas virtuales; ve como se comporta extraño luego de cambiar el tamaño de la ventana
 * Nota que las coordenadas del mouse en la pantalla son coordenadas físicas, y por lo tanto su rango cambia al modificar el tamaño de la ventana; modifica la demo para que muestre coordenadas virtuales.
 * Cambiar el código para que se pueda mover la etiqueta con las coordenadas del mouse cuando lo arrastras
 * Cambiar el código para que la información de teclas también muestre los modificadores con cada cambio


Cómo sigue?
-----------

Los ejemplos de este capítulo deberían ser suficientes para comenzar
a programar juegos arcade y para mouse simples.

El resto de esta guía sigue con algunos detalles bastante técnicos acerca de
algunas funcionalidades de cocos. Mientras comienzas, es recomendable que revises
las primeras líneas de cada capítulo pero no que intentes leer toda la guía de inicio
a fin.

Para un rendimiento óptimo en tus aplicaciones 2D deberás trabajar diréctamente con
OpenGL. Las referencias estándar para OpenGL son `The OpenGL Programming Guide`_ y
`The OpenGL Shading Language`_.

Como cocos2d usa pyglet también puedes consultar `pyglet Programming Guide`_ y
`pyglet API Reference`_

Hay muchos ejemplos de aplicaciones de cocos2d en el directorio ``samples/`` de la
documentación y en la distribución de código fuente. Consulta periódicamente
http://www.cocos2d.org/ para más ejemplos y tutoriales.



.. _The OpenGL Programming Guide: http://opengl.org/documentation/books/the_opengl_programming_guide_the_official_guide_to_learning_opengl_version
.. _The OpenGL Shading Language: http://opengl.org/documentation/books/the_opengl_shading_language_2nd_edition
.. _pyglet Programming Guide: http://pyglet.org/doc/programming_guide/
.. _pyglet API Reference: http://pyglet.org/doc/api/
.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html

